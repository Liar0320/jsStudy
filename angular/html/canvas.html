<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>canvas</title>
</head>
<body>
    <button onclick="getResult()">获取数据</button>
    <canvas id="myCanvas" width="960" height="590" style="position: relative;border:1px solid #dedede"></canvas>
</body>
    <script>
        'use strict'
        var c;
        var ctx;
        var resize = [12,12];
        var originalRect = {width:960,height:590};
        var baseRect = {width:1,height:1};
        //var rectAll = [];
        var storeOrigin=[];
        var storeRealRect = [];
        var result = [];
        var colors = ['#000','#abceff','#808080','#666666','#999999','#921209'];
        window.addEventListener("load",init);
        function init(){
           console.log("load"); 
           c = document.getElementById("myCanvas");
           ctx = c.getContext("2d");
           baseRect.width = originalRect.width/resize[0];
           baseRect.height = originalRect.height/resize[1];
          // initRectAll(...resize,rectAll,ctx);
           C_stroke(ctx,{x:0,y:0},{x:resize[0],y:resize[1]});
        }

        // function initRectAll(a,b,arr,ctx){
        //     for(var i=0 ;i< a;i++){
        //         arr[i] = [];
        //         for(var j=0 ;j< b;j++){
        //             arr[i][j] = baseRect;
        //            // rect(ctx,i,j);
                   
        //         }
        //     }
        // }

        // function rect(ctx,x,y){
        //     ctx.fillStyle = "red";
        //     ctx.fillRect(baseRect.width*x,baseRect.height*y,baseRect.width,baseRect.height);
        // }

        function C_stroke(ctx,posi1,posi2){
            ctx.strokeStyle = "#dedede"
            for(var x = posi1.x;x<posi2.x;x++){
                for(var y=posi1.y;y<posi2.y;y++){
                    ctx.beginPath();
                    ctx.moveTo(baseRect.width*x,baseRect.height*y);
                    ctx.lineTo(baseRect.width*(x+1),baseRect.height*y);
                    ctx.lineTo(baseRect.width*(x+1),baseRect.height*(y+1));
                    ctx.lineTo(baseRect.width*(x),baseRect.height*(y+1));
                //   ctx.endPath();
                    ctx.stroke();
                }
            }
        }

        function C_dash_rect(ctx,pois_1,pois_2){
           // ctx.clearRect(pois_1.x-96,pois_1.y-56,192,112);
            ctx.clearRect(0,0,960,590);
            ctx.strokeStyle = "#000"
            ctx.beginPath();
            ctx.moveTo(pois_1.x,pois_1.y);
            ctx.lineTo(pois_2.x,pois_1.y);
            ctx.lineTo(pois_2.x,pois_2.y);
            ctx.lineTo(pois_1.x,pois_2.y);
            ctx.closePath();
            ctx.stroke();
            console.log(pois_1,pois_2);
        }

        function RealRect(ctx,pois1,pois2,baseRect,index,colors){
            ctx.fillStyle = colors[index];
            ctx.fillRect(baseRect.width*pois1.x,baseRect.height*pois1.y
                        ,baseRect.width*(pois2.x-pois1.x),baseRect.height*(pois2.y-pois1.y));
        }

        function valid(x,y,baseRect,storeRealRect){
            var bool = true;
            bool = storeRealRect.reduce(function(bool,item,index){
                if((item.up.x*baseRect.width>x&&x>item.down.x*baseRect.width)&&(item.up.y*baseRect.height>y&&y>item.down.y*baseRect.height)){
                    bool = false;
                    return bool;
                }; //坐标是否在矩形内
                
                if((item.up.x*baseRect.width<x&&x<item.down.x*baseRect.width)&&(item.up.y*baseRect.height<y&&y<item.down.y*baseRect.height)){
                    bool = false;
                    return bool;
                }; //坐标是否在矩形外  包含情况

                return bool;
            },bool)
           // if(storeRealRect.length===0)bool = true;
            return bool;
        }
        function corssValid(down,up,baseRect,storeRealRect){
            var bool = true;
            bool = storeRealRect.reduce(function(bool,item,index){
                if((item.down.x*baseRect.width>down.x&&up.x>item.up.x*baseRect.width)&&((item.up.y*baseRect.height>up.y&&up.y>item.down.y*baseRect.height)||(item.up.y*baseRect.height>down.y&&down.y>item.down.y*baseRect.height))){
                    bool = false;
                    return bool;
                }; //判断矩形是否穿越 左右穿越
                
                if(((item.down.x*baseRect.width<down.x&&down.x<item.up.x*baseRect.width)||(item.down.x*baseRect.width<up.x&&up.x<item.up.x*baseRect.width))&&(item.up.y*baseRect.height<up.y&&down.y<item.down.y*baseRect.height)){
                    bool = false;
                    return bool;
                }; //判断矩形是否穿越 上下穿越

                if((item.down.x*baseRect.width>down.x&&up.x>item.up.x*baseRect.width)&&(item.up.y*baseRect.height<up.y&&down.y<item.down.y*baseRect.height)){
                    bool = false;
                    return bool;
                }; //判断矩形是否穿越 

                return bool;
            },bool)
           // if(storeRealRect.length===0)bool = true;
            return bool;
        }

        var keydown = false;
        myCanvas.addEventListener("mousemove",mousemove)
        myCanvas.addEventListener("mousedown",mousedown)
        myCanvas.addEventListener("mouseup",mouseup)
        function mousemove(e){
            if(keydown){
                C_dash_rect(ctx,storeOrigin,{x:e['offsetX'],y:e['offsetY']});
                C_stroke(ctx,{x:0,y:0},{x:resize[0],y:resize[1]});
                storeRealRect.forEach((item,index)=>{
                     RealRect(ctx,item.down,item.up,baseRect,index,colors);
                })
            }
        }
        function mousedown(e){
            if(keydown||!valid(e['offsetX'],e['offsetY'],baseRect,storeRealRect)) return;
            keydown = true;
            storeOrigin = {x:e['offsetX'],y:e['offsetY']};
            console.log(e['offsetX'],e['offsetY']);
        }
        function mouseup(e){
            if(!keydown||!(valid(e['offsetX'],e['offsetY'],baseRect,storeRealRect)&&
                           valid(e['offsetX'],storeOrigin.y,baseRect,storeRealRect)&&
                           valid(storeOrigin.x,storeOrigin.y,baseRect,storeRealRect)&&
                           valid(storeOrigin.x,e['offsetY'],baseRect,storeRealRect))) return;
   
            //四种生成矩形的方式 对应四种圆整方式
            if(storeOrigin.x>e['offsetX']){
                var down = {x:e['offsetX'],y:e['offsetY']}
                var up = storeOrigin;
            }else{
                var down = storeOrigin
                var up = {x:e['offsetX'],y:e['offsetY']};
            }
            if(down.y>up.y){
               var temp = 0;
               temp = down.y;
               down.y = up.y;
               up.y = temp
            }
            ////全部 转为 左上角  和有下角

            if(!corssValid(down,up,baseRect,storeRealRect)) return;

            down.x = Math.floor(down.x/ baseRect.width);  
            down.y = Math.floor(down.y / baseRect.height);  
            up.x = Math.ceil(up.x/ baseRect.width);  
            up.y = Math.ceil(up.y/ baseRect.height);  
         
            storeRealRect.push({down,up});
          //  C_stroke(ctx,down,up);
            storeRealRect.forEach((item,index)=>{
                     RealRect(ctx,item.down,item.up,baseRect,index,colors);
            })
            keydown = false;
            //RealRect(ctx,down,up);
            //console.log(e['offsetX'],e['offsetY']);
        }

        function transData(posi1,posi2,index,arr){
            for(var x = posi1.x;x<posi2.x;x++){
                arr[x]||(arr[x] = []);
                for(var y = posi1.y;y<posi2.y;y++){
                    arr[x][y] = index
                }
            }

            // for(var y = posi1.y;y<posi2.y;y++){
            //     arr[y]||(arr[y] = []);
            //     for(var x = posi1.x;x<posi2.x;x++){
            //         arr[y][x] = index
            //     }
            // }
        }

        function getResult(){
            storeRealRect.forEach((item,index)=>{
                transData(item.down,item.up,index,result)
            })
            console.log(result);
        }
    </script>
</html>

<noscript>
        var c ;
        var ctx_stroke;
        var tempPois = {x:0,y:0};
        var poisArr = [];
        window.addEventListener('load',load);
        function load(){
            console.log("load");
            c = document.getElementById("myCanvas");
            ctx_stroke = c.getContext("2d");
            ctx_paint = c.getContext("2d");
        }

        function C_stroke(ctx,pos,original){ 
            ctx.clearRect(0,0,960,590);
            ctx.strokeStyle ="#dedede";
            ctx.beginPath();
            ctx.moveTo(pos.x,original.y);
            ctx.lineTo(pos.x,pos.y);
            ctx.lineTo(original.x,pos.y);
            ctx.stroke();
        }
        function ctx_clip(ctx){ 
            ctx.fillRect(0,0,150,150);
            ctx.translate(75,75);

            // Create a circular clipping path
            ctx.beginPath();
            ctx.arc(0,0,60,0,Math.PI*2,true);
            ctx.clip()
        };
        var drawFrame=function(ctx,pos){
            ctx.clearRect(0,0,960,590);
            ctx.beginPath();
            ctx.strokeStyle="gray"
            ctx.moveTo(pos.x,0);
            ctx.lineTo(pos.x,pos.y);
            ctx.lineTo(0,pos.y);
            ctx.stroke();
        };
        function C_paint(ctx,pois,original){
            var x= 0;
            var y =0;
            if(pois.length ===0) return;
            if(pois.length>1) (x = original.x)&&(y=original.y);
            pois.forEach(pos=>{
                ctx.beginPath();
                ctx.strokeStyle="#000"
                ctx.moveTo(pos.x,y);
                ctx.lineTo(pos.x,pos.y);
                ctx.lineTo(x,pos.y);
                ctx.stroke();
            })
        }
        function checkPaint(posAll,pos){  
            if(poisArr.length ===0){
                return pos;
            } 
           var x = -1;
           var y = -1;
           posAll.forEach(item=>{
               (item.x<pos.x)&&(item.y>pos.Y)? (x<item.x? x= item.x:null):
               (item.x>pos.x)&&(item.y<pos.y)? (y<item.y? y = item.y:null)
               :null;
           })
           return (x>-1&&y>-1)?{x,y}:null;
        }
        myCanvas.addEventListener("mouseup",function(e){
            tempPois = checkPaint(poisArr,{x:e["offsetX"],y:e["offsetY"]});
            tempPois&&poisArr.push({x:e["offsetX"],y:e["offsetY"]});
            console.log({x:e["offsetX"],y:e["offsetY"]});
        })
        myCanvas.addEventListener("mousemove",function(e){
           // C_stroke.setAttribute('height','600px');
           C_stroke(ctx_stroke,{x:e["offsetX"],y:e["offsetY"]},tempPois); 
           C_paint(ctx_stroke,poisArr,tempPois);         
        })
    </noscript>

<noscript>
        var c ;
        var ctx_stroke;
        var tempPos = {};
        var rect = [0,0,960,590];
        var rectAll = [];
        window.addEventListener('load',load);
        function load(){
            console.log("load");
            c = document.getElementById("myCanvas");
            ctx_stroke = c.getContext("2d");
        }

        function C_stroke(ctx,pos,original){ 
            var x= rect[0];
            var y =rect[1];
            ctx.clearRect(...rect);
            ctx.strokeStyle ="#000";
            ctx.beginPath();
            ctx.moveTo(pos.x,y);
            ctx.lineTo(pos.x,pos.y);
            ctx.lineTo(x,pos.y);
            ctx.stroke();
        }
        
        // function collectRect(rectAll,rect){
        //     rectAll.push();
        // }

        function C_paint(ctx,pos,rect){
           // rectAll.push(0,0,...rect).contact();
            var x= 0;
            var y =0;
            ctx.beginPath();
         //   ctx.strokeStyle="#dedede"
            
            ctx.moveTo(x,0);
            ctx.lineTo(960,0);
            ctx.lineTo(960,590);
            ctx.lineTo(0,590);
            ctx.lineTo(0,y);
            ctx.lineTo(x,y);
           // ctx.closePath();
            ctx.stroke();
            ctx.clip();
        }
        function checkPaint(posAll,pos){  
    
        }
        myCanvas.addEventListener("mouseup",function(e){
            console.log({x:e["offsetX"],y:e["offsetY"]});
            tempPos = {x:e["offsetX"],y:e["offsetY"]};
            C_paint(ctx_stroke,tempPos,rect); 
        })
        myCanvas.addEventListener("mousemove",function(e){
           // C_stroke.setAttribute('height','600px');
           C_stroke(ctx_stroke,{x:e["offsetX"],y:e["offsetY"]}); 
              
        })
    </noscript>